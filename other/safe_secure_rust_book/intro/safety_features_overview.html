<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Safety Features - Safe and Secure Coding in Rust: A Comparative Analysis of Rust and C/C++</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introduction to The Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/rust_overview.html"><strong aria-hidden="true">1.1.</strong> Short Rust Overview</a></li><li class="chapter-item expanded "><a href="../intro/safety_features_overview.html" class="active"><strong aria-hidden="true">1.2.</strong> Rust Safety Features</a></li><li class="chapter-item expanded "><a href="../intro/example_app.html"><strong aria-hidden="true">1.3.</strong> Example Application</a></li></ol></li><li class="chapter-item expanded "><a href="../memory_safety/index.html"><strong aria-hidden="true">2.</strong> Memory Safety in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../memory_safety/undefined_behavior.html"><strong aria-hidden="true">2.1.</strong> Undefined Behavior</a></li><li class="chapter-item expanded "><a href="../memory_safety/buffer_overflow.html"><strong aria-hidden="true">2.2.</strong> Buffer Overflow</a></li><li class="chapter-item expanded "><a href="../memory_safety/use_after_free.html"><strong aria-hidden="true">2.3.</strong> Use After Free</a></li><li class="chapter-item expanded "><a href="../memory_safety/pointers.html"><strong aria-hidden="true">2.4.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../memory_safety/memory_leaks.html"><strong aria-hidden="true">2.5.</strong> Memory Leaks</a></li><li class="chapter-item expanded "><a href="../memory_safety/double_free.html"><strong aria-hidden="true">2.6.</strong> Double Free</a></li><li class="chapter-item expanded "><a href="../memory_safety/format_string.html"><strong aria-hidden="true">2.7.</strong> Format String</a></li></ol></li><li class="chapter-item expanded "><a href="../type_safety/index.html"><strong aria-hidden="true">3.</strong> Type Safety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type_safety/error_handling.html"><strong aria-hidden="true">3.1.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../type_safety/type_conversions.html"><strong aria-hidden="true">3.2.</strong> Type Conversions</a></li><li class="chapter-item expanded "><a href="../type_safety/uninitialized_variables.html"><strong aria-hidden="true">3.3.</strong> Uninitialized Variables</a></li><li class="chapter-item expanded "><a href="../type_safety/variable_overflow.html"><strong aria-hidden="true">3.4.</strong> Variable Overflow</a></li></ol></li><li class="chapter-item expanded "><a href="../concurrency/index.html"><strong aria-hidden="true">4.</strong> Concurrency Without Data Races</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrency/threads.html"><strong aria-hidden="true">4.1.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../concurrency/message_passing.html"><strong aria-hidden="true">4.2.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="../concurrency/is_shared_pointer_thread_safe.html"><strong aria-hidden="true">4.3.</strong> Is SharedPtr thread safe</a></li></ol></li><li class="chapter-item expanded "><a href="../unsafe/index.html"><strong aria-hidden="true">5.</strong> Safe Abstraction of Unsafe Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unsafe/unsafe_examples.html"><strong aria-hidden="true">5.1.</strong> Unsafe usage examples</a></li></ol></li><li class="chapter-item expanded "><a href="../rust_ecosystem/index.html"><strong aria-hidden="true">6.</strong> Rust Ecosystem</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust_ecosystem/rustup.html"><strong aria-hidden="true">6.1.</strong> Rustup</a></li><li class="chapter-item expanded "><a href="../rust_ecosystem/cargo.html"><strong aria-hidden="true">6.2.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="../rust_ecosystem/security_features.html"><strong aria-hidden="true">6.3.</strong> Security Features</a></li></ol></li><li class="chapter-item expanded "><a href="../cybersecurity_utils/index.html"><strong aria-hidden="true">7.</strong> Cybersecurity Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cybersecurity_utils/fuzzing.html"><strong aria-hidden="true">7.1.</strong> Fuzzing</a></li><li class="chapter-item expanded "><a href="../cybersecurity_utils/cryptography.html"><strong aria-hidden="true">7.2.</strong> Cryptography</a></li><li class="chapter-item expanded "><a href="../cybersecurity_utils/scanners.html"><strong aria-hidden="true">7.3.</strong> Scanners</a></li><li class="chapter-item expanded "><a href="../cybersecurity_utils/monitoring_tools.html"><strong aria-hidden="true">7.4.</strong> Monitoring Tools</a></li><li class="chapter-item expanded "><a href="../cybersecurity_utils/others.html"><strong aria-hidden="true">7.5.</strong> Others</a></li></ol></li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">8.</strong> Conclusion</a></li><li class="chapter-item expanded "><a href="../sources.html"><strong aria-hidden="true">9.</strong> Sources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Safe and Secure Coding in Rust: A Comparative Analysis of Rust and C/C++</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-compiler-safety-features-overview"><a class="header" href="#rust-compiler-safety-features-overview">Rust Compiler Safety Features Overview</a></h1>
<p>Rust's compiler is designed with safety as a primary goal, employing several key features to prevent common bugs and security vulnerabilities that plague systems programming. These features enforce strict compile-time checks, ensuring that only safe code gets executed unless explicitly marked otherwise. Below, we explore some of Rust's compiler safety features with examples.</p>
<h2 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h2>
<p>Rust's unique approach to memory management is enforced at compile time through its ownership and borrowing system, which eliminates a wide array of bugs related to memory usage, such as dangling pointers, double frees, and memory leaks.</p>
<h3 id="example-ownership-1"><a class="header" href="#example-ownership-1">Example: Ownership 1</a></h3>
<p><a href="https://godbolt.org/z/89PPW7oT6">GODBOLT</a></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a: String = String::from("Hello");
    let b = a; // a's ownership is moved to b
    println!("{}", b);
    // println!("{}", a); // This line would cause a compile-time error
}</code></pre></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string a = "hello";
    std::string b = a;  // Duplicate the data in a.
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h3 id="example-ownership-2"><a class="header" href="#example-ownership-2">Example: Ownership 2</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn greet(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Tom");
    greet(name);
    // greet(name);
}</code></pre></pre>
<p>In this example, the ownership of the string <code>a</code> is moved to <code>b</code>. Attempting to use <code>a</code> after this point results in a compile-time error, preventing use-after-move bugs.</p>
<h3 id="example-borrowing-1"><a class="header" href="#example-borrowing-1">Example: Borrowing 1</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}

fn main() {
    let a = String::from("Hello");
    let len = calculate_length(&amp;a); // a is borrowed
    println!("The length of '{}' is {}.", a, len); // a can still be used here
}</code></pre></pre>
<p>Here, <code>a</code> is borrowed by <code>calculate_length</code>, allowing <code>a</code> to be used afterward because it wasn't moved but merely borrowed.</p>
<h3 id="example-borrowing-2"><a class="header" href="#example-borrowing-2">Example: Borrowing 2</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn append_world(s: &amp;mut String) {
    s.push_str(" world"); // s is now a mutable reference, allowing us to modify the original String
}

fn main() {
    let mut a = String::from("Hello");
    append_world(&amp;mut a); // a is mutably borrowed
    println!("The new value of 'a' is {}.", a); // a can still be used here because the mutable borrow ends at the end of the `append_world` scope
}</code></pre></pre>
<p>Here, <code>a</code> is mutably borrowed by <code>append_world</code>, allowing <code>a</code> to be modified inside and to be used afterward.</p>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>In Rust, references have lifetimes that ensure they don't outlive the data they point to, thanks to the borrow checker. Lifetimes can be:</p>
<ul>
<li><strong>Implicit</strong>, where Rust automatically figures out the lifespan of references for you.</li>
<li><strong>Explicit</strong>, used in complex scenarios, where you guide Rust with lifetime annotations (like <code>'a</code>) to resolve ambiguities.</li>
</ul>
<p>The compiler uses these annotations to enforce safe reference usage, preventing errors related to invalid data access. Essentially, Rust's system manages reference validity for you, stepping in only when you need to clarify lifetimes in tricky situations.</p>
<h3 id="example-0-borrow-checker"><a class="header" href="#example-0-borrow-checker">Example 0: Borrow Checker</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let result;                     // ---------+-- 'a
    {                               //          |
        let tmp = 42;               // -+-- 'b  |
        result = &amp;tmp;              //  |       |
    }                               // -+       |
    println!("result: {}", result); //          |
}                                   // ---------+</code></pre></pre>
<p>In this example, the variable <code>result</code> is intended to have a longer lifetime, labeled <code>'a</code>, extending over the entire <code>main</code> function. Inside a nested block, we create <code>tmp</code> with a shorter lifetime, <code>'b</code>. We attempt to assign a reference to <code>tmp</code> to <code>result</code>. However, <code>'b</code> is much shorter than <code>'a</code> because <code>tmp</code> goes out of scope once the block ends, but <code>result</code> is used outside of this block.</p>
<p>Rust checks lifetimes at compile time and identifies that <code>result</code> is supposed to live longer than <code>tmp</code>, based on their respective scopes. Since <code>result</code> is a reference to <code>tmp</code>, which has a shorter lifespan, Rust prevents this by design, to avoid dangling references. Essentially, Rust disallows the program because the data <code>result</code> points to (<code>tmp</code>) does not exist for the entirety of <code>result</code>'s lifetime. This ensures memory safety by preventing access to invalid or deallocated memory.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example 1:</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";

        let result = longest(string1.as_str(), string2);
        println!("The longest string is {}", result);
    }
}</code></pre></pre>
<p>This function signature tells Rust that the returned reference will live as long as the <code>shortest</code> of the two input references, ensuring the reference is valid for the duration of its use.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example 2:</a></h3>
<pre><pre class="playground"><code class="language-rust editable">struct User&lt;'a&gt; {
    username: &amp;'a str,
}

struct Tweet&lt;'a&gt; {
    content: &amp;'a str,
    author: &amp;'a User&lt;'a&gt;,
}

impl&lt;'a&gt; Tweet&lt;'a&gt; {
    fn is_tweet_by_user(&amp;self, user: &amp;'a User) -&gt; bool {
        self.author.username == user.username
    }
}

fn main() {
    let user = User { username: "johndoe" };
    let tweet = Tweet {
        content: "Hello, world!",
        author: &amp;user,
    };

    if tweet.is_tweet_by_user(&amp;user) {
        println!("This tweet is by {}", user.username);
    } else {
        println!("This tweet is not by {}", user.username);
    }
}</code></pre></pre>
<p>This example demonstrates how explicit lifetime annotations guide the Rust compiler to enforce memory safety in scenarios where relationships between data (like tweets and their authors) are managed through references.
I have created a <code>User</code> and a <code>Tweet</code> structs, then use the method <code>is_tweet_by_user</code> to check if the tweet was authored by the user. This entire flow is safe thanks to Rust's lifetimes, ensuring the references in Tweet and User are valid when accessed.</p>
<h2 id="match-control-flow"><a class="header" href="#match-control-flow">Match Control Flow</a></h2>
<p>The <code>match</code> control flow construct forces handling of all possible cases when used with enums, reducing the chances of bugs from unhandled cases.</p>
<h3 id="example-match-with-enums"><a class="header" href="#example-match-with-enums">Example: Match with Enums</a></h3>
<pre><pre class="playground"><code class="language-rust">enum Command {
    Start(String), // Contains a message
    Stop,
    Restart { delay_secs: u32 }, // Contains named fields
}

fn execute_command(command: Command) {
    match command {
        Command::Start(message) =&gt; println!("Starting: {}", message),
        Command::Stop =&gt; println!("Stopping"),
        Command::Restart { delay_secs } =&gt; println!("Restarting in {} seconds", delay_secs),
        _ =&gt; println!("Unknown Command!"),
    }
}

fn main() {
    let start_command = Command::Start(String::from("Hackathon 2024"));
    execute_command(start_command);

    let stop_command = Command::Stop;
    execute_command(stop_command);

    let restart_command = Command::Restart { delay_secs: 5 };
    execute_command(restart_command);
}</code></pre></pre>
<h2 id="safe-concurrency"><a class="header" href="#safe-concurrency">Safe Concurrency</a></h2>
<p>Rust's ownership and type system ensure safe concurrency, preventing data races at compile time.</p>
<h3 id="example-safe-concurrency"><a class="header" href="#example-safe-concurrency">Example: Safe Concurrency</a></h3>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
use std::thread;

fn main() {
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter_clone = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            // Safely increment the counter
            counter_clone.fetch_add(1, Ordering::Relaxed);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Counter: {}", counter.load(Ordering::Relaxed));
}</code></pre></pre>
<p>This example uses <code>Arc</code> (Atomic Reference Counting) to safely share and access data across threads.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Rust's compiler safety features are central to its promise of safe systems programming, effectively addressing many of the pitfalls common in other languages. Through ownership, lifetimes, match statements, and safe concurrency, Rust empowers developers to write more reliable and secure code by default, catching potential errors early in the development cycle. These features, backed by a thorough compile-time checking system, make Rust an appealing choice for projects where safety and performance are paramount.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../intro/rust_overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../intro/example_app.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../intro/rust_overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../intro/example_app.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
